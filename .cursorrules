# Simple Tweet Queue Scheduler - Cursor Rules

## Project Context
**MVP COMPLETE** - Building Simple Queue Scheduler
- v1.0: Basic AI tweet scheduler with Twitter integration âœ…
- v2.0: Simple automated queue with 5 tweets/day scheduling
- Status: Production-ready AI tweet scheduler

## Tech Stack
- Frontend: Next.js 14 with TypeScript
- Database: Supabase - **MCP Integrated**
- Scheduling: QStash by Upstash
- Styling: Tailwind CSS
- Deployment: Vercel

---

## ğŸš¨ CRITICAL DEPLOYMENT ENVIRONMENT RULES

### ğŸ›¡ï¸ **CATASTROPHIC DATA LOSS PREVENTION** 
**MANDATORY:** NEVER delete USER DATA without explicit permission
```
ğŸš¨ CRITICAL: User is on FREE TIER - NO AUTOMATIC BACKUPS
âŒ NEVER delete tables/data that contain USER INPUT without explicit consent
âŒ NEVER run "reset", "rollback", or "clean" operations that delete USER DATA
âŒ NEVER delete user-generated content (tweets, settings, connections, etc.)
âŒ NEVER run destructive operations on populated tables without user approval
âœ… ALWAYS ask permission before deleting USER DATA (not empty schema)
âœ… ALWAYS warn about FREE TIER = NO BACKUPS before deleting USER DATA
âœ… Schema creation/modification for empty tables = NO PERMISSION NEEDED
âœ… Creating new tables or rebuilding empty schema = PROCEED WITHOUT ASKING
```

**USER DATA vs SCHEMA DISTINCTION:**
- **USER DATA** (requires permission): Tweets, writing samples, Twitter connections, queue settings, user preferences
- **EMPTY SCHEMA** (no permission needed): Creating tables, indexes, constraints, RLS policies on empty tables

**DESTRUCTIVE OPERATION CHECKLIST:**
Before ANY operation that could delete USER DATA:
1. âš ï¸ **STOP** - Does this table contain user input/data?
2. ğŸ” **VERIFY** - Will this delete actual user-generated content?
3. ğŸ“‹ **CHECK** - Is user on paid plan with backups?
4. ğŸ’¬ **ASK** - Get explicit user permission for USER DATA deletion
5. âš ï¸ **WARN** - Explain FREE TIER = NO RECOVERY for user data
6. âœ… **CONFIRM** - Double-check user wants to proceed

### ğŸŒ **NEVER ASSUME LOCAL DEVELOPMENT**
**MANDATORY:** This project runs in production on Vercel, NOT localhost
```
âŒ NEVER assume localhost or local development environment
âŒ NEVER use http://localhost:3000 in examples or debugging
âŒ NEVER suggest running curl commands against localhost
âœ… ALWAYS assume production Vercel deployment
âœ… Environment variables are configured through Vercel dashboard
âœ… NEXT_PUBLIC_SITE_URL is set via Vercel (not local .env)
```

### ğŸ”§ **VERCEL DEPLOYMENT CONTEXT**
- **Environment Variables**: Managed through Vercel dashboard (not local .env files)
- **NEXT_PUBLIC_SITE_URL**: Configured via Vercel (points to production domain)
- **API Endpoints**: Live on Vercel domain, not localhost
- **Database**: Supabase production instance
- **QStash Webhooks**: Must reach public Vercel domain

### ğŸ“¡ **API TROUBLESHOOTING MANDATE**
**CRITICAL:** When troubleshooting any API-related issues:
1. **ALWAYS web_search for latest API documentation** (check current year 2025)
2. **Verify API endpoints, parameters, and response formats** are current
3. **Check for breaking changes** in the last 6-12 months
4. **Ensure API integration follows latest best practices**
5. **Never assume API behavior** - always verify with current docs

### ğŸ” **DEBUG AUTHENTICATION HANDLING**
**CRITICAL:** When debugging /debug/ routes on Vercel production:
1. **Bearer Token Setup:** Ensure debug routes check for authorization header
2. **Environment Variables:** Debug token stored securely in Vercel environment
3. **Debug Route Pattern:** `/app/api/debug/*` routes require authentication
4. **Authorization Header:** Format: `Authorization: Bearer ${DEBUG_TOKEN}`
5. **Fallback Access:** Provide alternative access method if bearer fails
6. **Security:** Never expose debug endpoints without authentication in production
7. **Debug Flow:** Always test debug authentication works before debugging issues

---

## ğŸš¨ CRITICAL SAFEGUARDS (Prevent Hours of Troubleshooting)

### ğŸ“š API INTEGRATION STRATEGY - CHECK EXISTING FIRST
**MANDATORY:** Before ANY API work, check what's already integrated
```
1. EXISTING APIs (Keys Already Set):
   âœ… Supabase (NEXT_PUBLIC_SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY, etc.)
   âœ… QStash (QSTASH_TOKEN) - Scheduling service
   âœ… Twitter API (TWITTER_API_KEY, TWITTER_API_SECRET) - OAuth + posting

2. ONLY for NEW APIs:
   - web_search: "[API NAME] documentation 2025"
   - Verify parameter formats, response structures, rate limits
   - Check for breaking changes in last 6 months
   - Get API keys from user

3. For EXISTING APIs:
   - Assume keys are already configured via Vercel
   - web_search: "[API NAME] latest documentation 2025" to verify current API
   - Check current documentation for updates/changes
   - Verify we're using latest best practices
```

### ğŸ—„ï¸ DATABASE MANAGEMENT WITH MCP SUPABASE
**CONTEXT:** MCP Supabase provides direct database interaction - no manual SQL files needed
**INTEGRATION:** Database schema and operations handled through MCP tools

**ğŸš¨ CRITICAL MCP SUPABASE SAFEGUARDS:**
```
ğŸ›¡ï¸ DATA LOSS PREVENTION WITH MCP SUPABASE:
âŒ NEVER use mcp_supabase_apply_migration with DROP TABLE without user permission
âŒ NEVER run migrations named "reset", "rollback", "clean" without explicit consent
âŒ NEVER assume migration operations are safe - always check SQL content first
âŒ NEVER run destructive operations based on assumptions or "cleanup" needs
âœ… ALWAYS show user the SQL before running destructive migrations
âœ… ALWAYS ask permission before DROP, TRUNCATE, or DELETE operations
âœ… ALWAYS remind user about FREE TIER = NO BACKUPS before destructive operations
âœ… ALWAYS get explicit "YES" confirmation for any data deletion
```

**DESTRUCTIVE MCP OPERATION PROTOCOL:**
1. ğŸ“‹ **INSPECT** - Check what SQL will be executed
2. ğŸ” **ANALYZE** - Look for DROP, TRUNCATE, DELETE keywords
3. âš ï¸ **WARN** - Alert user about potential data loss
4. ğŸ’¬ **ASK** - Get explicit permission with clear explanation
5. â¸ï¸ **WAIT** - For user's explicit "YES" response
6. âœ… **EXECUTE** - Only after confirmed permission

**WORKFLOW:**
1. **Database Changes:** Use MCP Supabase tools for schema management
2. **Live Database:** Direct interaction through MCP eliminates manual SQL execution
3. **Schema Inspection:** MCP provides real-time database schema information
4. **Data Operations:** Use MCP for queries, inserts, updates, and migrations

**NO LONGER NEEDED:**
- âŒ Manual `database-schema.md` files
- âŒ Manual `database-rollback-commands.md` files  
- âŒ Manual SQL migration files
- âŒ Manual verification scripts
- âŒ Manual deployment state tracking

---

## ğŸ” CODE QUALITY & ESLINT PREVENTION
**MANDATORY:** Prevent build failures by following these rules BEFORE committing

### **ESLint Rules to Follow:**
1. **TypeScript Strictness:**
   - âŒ NEVER use `any` type - create proper interfaces instead
   - âœ… Use `const` for variables that are never reassigned (not `let`)
   - âœ… Define proper types for function parameters and returns
   - âœ… Use type guards for runtime type checking

2. **React/JSX Rules:**
   - âŒ NEVER use unescaped quotes in JSX: `"text"` 
   - âœ… Always escape quotes: `&quot;text&quot;` or `&ldquo;text&rdquo;`
   - âœ… Use proper event handler types: `React.MouseEvent`, `React.ChangeEvent`
   - âœ… Include `key` props for mapped elements

3. **Variable Declaration:**
   - âœ… Use `const` for values that never change
   - âœ… Use `let` only when the variable will be reassigned
   - âŒ Avoid `var` completely

### **Pre-Commit Checklist:**
Before ANY git commit, verify:
- [ ] No TypeScript errors (`any` types, missing interfaces)
- [ ] No unescaped entities in JSX (quotes, apostrophes)
- [ ] Proper const/let usage (prefer const when possible)
- [ ] All imports are used and correctly typed
- [ ] Event handlers have proper TypeScript types

### **Common Pitfalls & Fixes:**
```typescript
// âŒ BAD: Using 'any' type
const items = data.map((item: any) => ({ ... }))

// âœ… GOOD: Proper interface
interface DatabaseItem { id: string; name: string; }
const items = data.map((item: DatabaseItem) => ({ ... }))

// âŒ BAD: Using 'let' when never reassigned
let config = { apiKey: '...', timeout: 5000 }

// âœ… GOOD: Using 'const' 
const config = { apiKey: '...', timeout: 5000 }

// âŒ BAD: Unescaped quotes in JSX
<span>Click "Save" to continue</span>

// âœ… GOOD: Escaped quotes
<span>Click &quot;Save&quot; to continue</span>
```

### **Build Validation Process:**
1. **Direct Deployment Testing:** Commit and push to test on Vercel production
2. **Type Check:** Ensure all TypeScript types are properly defined
3. **ESLint Clean:** No warnings or errors in ESLint output
4. **Import Check:** All imports are used and paths are correct

---

## ğŸ”§ QUEUE SCHEDULER SPECIFIC RULES

### Queue Management
- **Daily Slots:** 5 tweets per day with natural timing variation
- **Time Window:** 8 AM - 9 PM with automatic spacing
- **Auto-Advance:** Automatically move to next day when current day is full
- **Natural Timing:** Minutes vary daily to appear more human

### Scheduling Logic
- **Base Times:** Calculate evenly spaced times in 13-hour window
- **Minute Variation:** Â±10 minutes random offset per day
- **Queue Display:** Show which day each tweet will be posted
- **Status Tracking:** Clear indication of tweet status (queued, scheduled, posted)

---

## ğŸ“‹ DEVELOPMENT WORKFLOW

### Before Starting ANY Phase:
1. âœ… Check current API documentation (web_search)
2. âœ… Use MCP Supabase for database schema inspection
3. âœ… Test database operations through MCP before implementation

### Database Changes:
1. **Inspect Current Schema:** Use MCP Supabase tools to understand current state
2. **Plan Changes:** Define required schema modifications
3. **Implement:** Use MCP for direct database modifications
4. **Verify:** Use MCP to confirm changes applied correctly
5. **Test:** Ensure application works with new schema

### API Integration:
1. **Research:** web_search for current documentation
2. **Debug Route:** Create simple test endpoint first
3. **Parameters:** Verify formats match current docs
4. **Error Handling:** Handle rate limits and failures
5. **Testing:** Test edge cases and error scenarios

---

## ğŸ—‚ï¸ FILE ORGANIZATION

```
AI-Personality-Tweets-to-Scheduler/
â””â”€â”€ src/
    â”œâ”€â”€ components/
    â”‚   â”œâ”€â”€ TweetQueueManager.tsx   # Main queue interface
    â”‚   â”œâ”€â”€ QueueDisplay.tsx        # Visual queue with dates
    â”‚   â””â”€â”€ TweetInputForm.tsx      # Simple tweet input
    â”œâ”€â”€ lib/
    â”‚   â”œâ”€â”€ queue-scheduler.ts      # Core scheduling logic
    â”‚   â”œâ”€â”€ timing-algorithm.ts     # Natural timing calculation
    â”‚   â””â”€â”€ auto-advance.ts         # Day advancement logic
    â””â”€â”€ app/api/
        â”œâ”€â”€ queue-tweet/            # Add tweet to queue
        â”œâ”€â”€ process-queue/          # Process and schedule
        â””â”€â”€ queue-status/           # Get queue state
```

---

## âš ï¸ COMMON QUEUE SCHEDULER PITFALLS TO AVOID

### Queue Management Issues:
- **Day Overflow:** Ensure queue properly advances to next day when full
- **Time Calculation:** Verify even spacing between posts (2.6 hour intervals)
- **Minute Variation:** Don't make timing too random - keep it natural
- **Queue Status:** Always show clear feedback on which day tweets will post

### Scheduling Issues:
- **Timezone Handling:** All times must be in user's timezone
- **QStash Integration:** Verify webhook URLs point to production domain
- **Error Recovery:** Handle failed scheduling gracefully
- **Status Tracking:** Keep tweet status updated throughout process

---

## ğŸš¨ CRITICAL USER CONTEXT - FREE TIER LIMITATIONS

**âš ï¸ IMPORTANT: USER IS ON SUPABASE FREE TIER**
```
ğŸ”´ NO AUTOMATIC BACKUPS - Data loss is PERMANENT
ğŸ”´ NO POINT-IN-TIME RECOVERY - Cannot restore to previous state
ğŸ”´ NO DAILY BACKUPS - Zero recovery options if data is deleted
ğŸ”´ CATASTROPHIC IMPACT - Any data deletion is irreversible
```

**BEFORE ANY DATABASE OPERATION:**
1. ğŸ›‘ **REMEMBER** - User has NO backups
2. ğŸ’­ **THINK** - Could this delete data?
3. ğŸš¨ **STOP** - If yes, ask permission first
4. ğŸ“¢ **WARN** - Explain FREE TIER = NO RECOVERY
5. âœ… **CONFIRM** - Get explicit user consent

## ğŸ¯ CURRENT DEVELOPMENT PRIORITIES

**Current Focus:** Improving user experience and AI quality
1. **Bug Fixes:** Address high-priority user experience issues
2. **AI Output Quality:** Make tweets sound more human and natural
3. **Enhanced Voice Matching:** Better writing sample utilization
4. **User Experience:** Improve queue management and interface
5. **Database Safety:** CRITICAL - User has NO backups on free tier
6. **Production-Only Approach:** Use feature flags, no test environment needed

---

## ğŸ›‘ TROUBLESHOOTING WORKFLOW (Prevent Getting Stuck)

### **3-Attempt Rule**: 
If working on the same problem for more than 3 attempts based on user feedback:

1. **STOP** making agentic attempts
2. **MANDATORY API CHECK**: web_search for latest API documentation (2025)
3. **SWITCH TO PLAN MODE:**
   - **Analyze**: What exactly is wrong?
   - **Logic**: What are we trying to fix and why?
   - **API Verification**: Are we using current API methods/parameters?
   - **Environment**: Remember this is Vercel production, not localhost
   - **Impact**: How does this affect the overall queue scheduler plan?
   - **Strategy**: Clear step-by-step plan to resolve the issue
4. **Present the analysis** to user for agreement
5. **Continue with 3 more attempts** after plan approval

### **Plan Mode Template:**
```
ğŸ›‘ **SWITCHING TO PLAN MODE** (3+ attempts on same issue)

**Problem Analysis:**
- What's broken: [specific issue]
- Root cause: [why it's happening]
- Current attempts tried: [list what was tried]

**API Verification:** (MANDATORY)
- Latest API docs checked: [Y/N + search results]
- API methods/parameters verified current: [Y/N]
- Breaking changes identified: [list any found]
- Environment context: Vercel production (not localhost)

**Fix Strategy:**
- Step 1: [specific action]
- Step 2: [specific action]
- Step 3: [specific action]

**Overall Impact:**
- How this affects queue scheduler development
- Which phases might be delayed
- Dependencies that are blocked

**Next Steps:**
- Immediate actions needed
- Success criteria to confirm fix
- Backup plan if this approach fails
```

---

## ğŸ“ REFERENCE CHECKLIST

Before any major work:
- [ ] Current API docs checked (web_search)
- [ ] Database schema inspected via MCP Supabase
- [ ] Not stuck on same problem for 3+ attempts

**Before ANY commit:**
- [ ] Code Quality: No `any` types, proper interfaces defined
- [ ] ESLint Clean: No unescaped JSX entities, proper const/let usage
- [ ] Type Safety: All imports typed correctly
- [ ] Testing: Commit and push to validate on Vercel production

**MCP Supabase Integration Benefits:**
- âœ… Real-time database schema inspection
- âœ… Direct database operations without manual SQL
- âœ… Automatic pgvector extension management
- âœ… Simplified database development workflow

Remember: The queue scheduler introduces automated timing and queue management. Use MCP Supabase for efficient database management and take time to research APIs to avoid costly mistakes. 

- When testing, instead of npm run process, let's go ahead and git add commit push so we can deploy it directly to vercel and i can take a look there. Don't test debug at endpoint ie npm run test. But before doing the push (to vercel), make sure there are no missing dependencies, make sure we don't get Warning: Failed to fetch one or more git submodules, make sure we don't get Warning: Unused eslint-disable directive, and so we don't get failed to compile
- this is my url https://ai-tweet-scheduler.vercel.app/
- when we debug let us make it not require authentication or bearer token
